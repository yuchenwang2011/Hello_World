This file is the note I took during preparing OO concepts and some Java knowledge.

Basic concepts:
1. Object-oriented programming lets you extend a program without having to touch previously testd, working code. 

2. Instance variables are things an object knows about itself. They represent the state of an object. 

3. public static void main, static here means that method can be run without instantiate an instance of main. static variables and methods belongs to the class not a specific instance.

4. 8 Java primitive types: Be careful! Bears shoudn't ingest large fury dogs. 
                        boolean, char, byte, short,   int,  long, float, double 

5. Java is pass by value, means pass by copy. 
   int x = 7; foo.go(x);
   go() won't change the value of x because go() was given a copy of x;

6. Java has 4 OOP concepts: a pie: Abstraction, Polymorphism, Inheritance, Encapsulation
   Encapsulation: also known as data hiding, instance variables of a class is hiden from other classes and it's only accessable by
                  methods in current class. The variables of a class is private and only can be accessed 
                  and modified by getter and setter.
   Polymorphism: We can use a super class reference for a subclass object, you only know the object the reference points to when 
                 executing. With polymorphism, you don't need to change your code when a new subclass is introduced. 
      Animal[] animals = new Animal[3];
       animals[0] = new Dog();
       animals[1] = new Cat();
       animals[2] = new Wolf(); 
   Inheritance advantage: When you want to create a new class and there is already a class that includes some of the code that you want
                          ,you can derive your new class from the existing class. In doing this, 
                          you can reuse the fields and methods of the existing class without having to write and debug them yourself.
                          When you modify the code, just modify the super class, you don't need to touch the subclasses.

7. When you instanciate an array, Dog[] myDog = new Dog[7]; //here Dog[0], Dog[1] is still reference
   You need myDog[0] = new Dog(); myDog[1] = new Dog();

8. null is not an object, it's a reference.

9. Java Access Levels
   Modifier	  Class	Package	Subclass	World
   public	      Y	    Y	       Y	      Y
   protected	  Y	    Y	       Y	      N
   no modifier	Y	    Y      	 N	      N
   private	    Y	    N	       N	      N

10. When calling a method on an object reference, it starts from the lowest level of the inheritance tree. 

11. When A class extends B class, A must IS-A B, otherwise the design is wrong

12. Overload: Methods within a class can have the same name if they have different parameter lists

13. Abstract Class: some classes shouldn't be instantiated, add keyword "abstract" before class, then the class can't be instantiated.
    You can also use abstract method, such as public abstract void eat(); When you use an abstract method, you must also mark the class
    to be abstract as well. The main purpose for an abstract class is polymophism. 
    
14. When you initiate an array of abstract class Animal, Animal[] myAni = new Animal[5]; Don't worry, this is just an array. No objects
    are instantiated in array Animal.
    
15. You can only call a method of an object, only if the class of the reference variable has that method. 

16. Interface: an interface is a 100% abstract class, all the methods must be abstract, all the subclasses must override and implement
               the abstract classes. An interface gives you powerful polymophism. 
               public interface Pet{
                  //in an interface, all the methods are actually public and abstract even you don't write the keywords
                  public abstract void beFriendly(); // you can have a curly braces here because it's abstract
                  public abstract void play();
               }
               public class Dog extends Canine implements Pet{...}
               public class Dog extends Canine implements Pet, Savable, Paintable{...} 
               A java class can only have 1 parent super class. Parent class defines who you are 
               and interfaces define what role you play. 
17. Use super.method() to use parent's method of this object.

18. Java has a stack, where local variables and methods live, it's like the stack idea in data structure, 
    and heap(garbage collectible heap), where objects live (Since instance variable is in a class, it lives inside of the object). 

19. Constructor, example: public Duck(){  // this is a default one, note it must have same name as class and no return type
                          }
    You can have many constructors, but once you create one given an argument, you'd better write a non-arg one yourself. When you 
    write one the compiler won't create a default one anymore. And you can write many constructors, this is called, overloaded 
    constructors, and the order of argument can be different, for example, the below 2 constructors are different and both are valid.
    public mushroom(boolean isMagic, int size) {}
    public mushroom(int size, boolean isMagic){}

    All the constructors in the inheritance tree will run when a new object is created (like an onion). 
    Even abstract class has a constructor. This is called constructor chaining. The lowest part of the tree is executed first,
    but it's the reason it's in the lowest stack frame position -- the last one to be executed! So the second last one of the stack 
    frame is it's superclass. 
    So the object() constructor is on top of the stack frame. see Head First Java page 252. The compiler is actually calling 
    super() automatically if you don't. Just think about a child can't be born before a parent. 
    So super() should be the first statement in each constructor!!
    Use this() to call a constructor from another overloaded constructor in the same class. It has to be the first statement in the
    constructor too!!! So super() and this() can't appear at the same time. 

20. static lets a method run without any instance of the class. Sometimes you can't instantiate an abstract class, so you use static 
    method. Static methods can't use non-static instanace variables, nor the non-static methods. 
    Static variable: value is hte same for all instances of the class, it lives in the class. Say you have newed 3 objects, they all 
    use the same static variable. The static variable is initialized when a class is loaded, or to say, before a new object is created,
    the static variable is already there. Static final variables are contants, like PI. Constant variable names must be in all caps!
    A static initializer:
                  class Foo{
                    final static int FOO_X; //should be in all caps
                    static {
                      FOO_X = 42;
                    }
                  }
    
21. When you write a risky method, you must decare it will throw an exception. 
    public void takeRisk() throws Exception {
        if(abandonAllHope) throw new Exception();
    }

    try {
       anObject.takeRisk();
    } catch (Exception ex) {
       //something to recover
    }
    The compiler won't check RunTimeExceptions.
